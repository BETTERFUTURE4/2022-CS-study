> 스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다.
<토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리> (이일민 지음)
>

# intro

## 객체지향 프로그래밍

객체지향 프로그래밍은 어플리케이션을 설계할 때 책임과 관심사에 따라 클래스를 분리합니다.

클래스가 단일 책임을 가지도록 분리함으로써 각 모듈의 응집도는 높아지고 결합도는 낮아집니다.

클래스를 변경하는 이유는 오직 한 가지이며, 어플리케이션의 한 부분에서 변경이 발생했을 때 그 파급효과가 시스템의 전체로 퍼져나가는 정도가 낮아집니다.

## 관심사의 분리

그러나 전통적인 객체지향 설계 방식을 충실히 따르더라도 한 가지 아쉬운 점이 존재합니다. **여러 클래스에 로깅이나 보안 및 트랜잭션 등 공통된 기능들이 흩어져 존재한다는 점**입니다.

---

# AOP

### **AOP란?**

Spring의 핵심 개념중 하나인 DI가 애플리케이션 모듈들 간의 결합도를 낮춰준다면, AOP는 **애플리케이션 전체에 걸쳐 사용되는 기능을 재사용**하도록 지원하는 것입니다.

AOP (Aspect-Oriented Programming) 란 단어를 번역하면 **관점(관심) 지향 프로그래밍**으로 됩니다. 쉽게 얘기하면 프로젝트 구조를 바라 보는 **관점**을 바꿔보자는 이야기입니다. 즉, **대상을 바라보는 방향을 바꿔보자** 라는 이야기입니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fe9c184e-202e-4802-b1b8-a0349c8203d1/Untitled.png)

각각의 Service는 핵심기능에서 바라보았을때는 Board, User, XXX 등 **공통된 요소가 없습니다**. 이런 관점에서는 각각의 Service는 각자 코드를 구현하고 있습니다.

하지만, 이 관점을 돌려서 **부가기능**이란 관점에서 바라보면 상황이 달라집니다. 부가기능의 관점에서 바라보면 각각의 Service는 수행시간 측정을 나타내는 before라는 메소드와 after라는 메소드가 공통되는 것을 알 수 있습니다.

**AOP는 여기서부터 시작합니다.** 기존에 OOP에서 바라보던 관점을 다르게 하여 부가기능적인 측면에서 보았을때 공통된 요소를 추출하자는 것입니다.

이때 가로(횡단) 영역의 공통된 부분을 잘라냈다고 하여, AOP를 **크로스 컷팅(Cross-Cutting)** 이라고 불리기도 합니다.

## 용어

**타겟 (Target)**

타깃은 부가기능을 부여할 대상이다. 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.

**애스펙트 (Aspect)**

객체지향 모듈을 오프젝트라 부르는것과 비슷하게 부가기능 모듈을 애스펙트라고 부르며, **핵심기능에 부가되어 의미를 갖는** 특별한 모듈이라 생각하시면 됩니다.

애스펙트는 부가될 기능을 정의한 **어드바이스** 와 어드바이스를 어디에 적용할지를 결정하는 **포인트컷** 을 함께 갖고 있습니다.

참고로 AOP(Aspect Oriented Programming)라는 뜻 자체가 어플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스팩트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 얘기합니다.

**어드바이스 (Advice)**

실질적으로 부가기능을 담은 구현체를 얘기합니다. 어드바이스의 경우 타겟 오프젝트에 종속되지 않기 때문에 순수하게 **부가기능에만 집중** 할 수 있습니다. 어드바이스는 애스펙트가 '무엇'을 '언제' 할지를 정의하고 있습니다.

어드바이스는 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다.

**포인트컷 (PointCut)**

부가기능이 적용될 대상(메소드)즉, 조인포인트를 선별하는 기능을 정의한 모듈을 애기합니다.

스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있다.

그래서 포인트컷 표현식은 메소드의 실행이라는 의미인 execution으로 시작하고, 메소드의 시그니처를 비교하는 방법을 주로 이용한다.

**조인포인트 (JoinPoint)**

어드바이스가 적용될 수 있는 위치를 얘기합니다.

스프링의 프록시 AOP에서 조인 포인트는 **메소드**의 실행 단계뿐이다. 타깃 오브젝트가 구현한 인터페이스의 모든 **메소드**는 조인 포인트가 된다.

## AOP 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/11650611-db8a-418f-9c98-816d977b2c28/Untitled.png)

- 여기서 트랜잭션 경계 설정이 문제…

> 아예 트랜잭션 코드가 존재하지 않는 것처럼 사라지게 할 수는 없을까? 물론 코드에 마법을 걸 수도 없는 노릇이고 꼭 필요한 기능을 담당하는 코드라고 그냥 안 보이게 할 방법은 없다. 하지만 적어도 UserService에서는 보이지 않게 할 수 있지 않을까? 간단하게 트랜잭션 코드를 클래스 밖으로 뽑아내면 된다.
<토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리> (이일민 지음) 중에서
>



그래서 다음 방식으로 구조를 변경한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a99374f6-53f0-4769-af3e-d4d8f0c18061/Untitled.png)

> UserService를 구현한 또 다른 구현 클래스(**UserServiceTx**)를 만든다.
이 클래스는 단지 트랜잭션의 경계설정이라는 책임을 맡고 있을 뿐이다.

그리고 스스로는 비즈니스 로직을 담고 있지 않기 때문에
또 다른 비즈니스 로직을 담고 있는 UserService의 구현 클래스에 실제적인 로직 처리 작업은 위임하는 것이다.

그 위임을 위한 호출 작업 이전과 이후에 적절한 트랜잭션 경계를 설정해주면, 클라이언트 입장에서 볼 때는 **결국 트랜잭션이 적용된 비즈니스 로직의 구현**이라는 기대하는 동작이 일어날 것이다.
<토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리> (이일민 지음) 중에서
>

즉, **UserServiceImpl**은 비즈니스 로직을 담당하고 **UserServiceTx**는 부가기능(트랜잭션)을 담당한다.

### **UserServiceTx(트랜잭션 기능 추가 클래스, 프록시) 구조**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/33650b7a-d20e-4f37-9470-f1e740259015/Untitled.png)

**UserServiceTx(프록시)**는 인터페이스 상속  + Bean 등록된 인터페이스를 호출(조합) 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0655efbe-0d60-494c-ba99-711199b4e62f/Untitled.png)

이후 해당 메소드별로 트랜잭션이 필요할 시 적용한다.

현재 호출구조이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bcc30a0-d128-4b11-a41e-d86b5576d24a/Untitled.png)

## 데코레이터 패턴

> 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
<토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리> (이일민 지음) 중에서
>

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/261c0e3c-fabc-4de9-85ed-976961ee8a7f/Untitled.png)

해당 패턴은 데코레이터 패턴이다.

> 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 **자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.**
>

> 그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.
<토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리> (이일민 지음) 중에서
>

### 프록시 패턴

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fbbfbca1-6ee1-4878-8526-106e2b45a8cb/Untitled.png)

> 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다. 그런데 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있다.
>

> 이럴 때 프록시 패턴을 적용하면 된다. 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트는 만드는 대신 프록시를 넘겨주는 것이다.
>

> 그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
>

> 만약 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나, 많은 작업이 진행된 후에 사용되는 경우라면, 이렇게 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다.
<토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리> (이일민 지음) 중에서
>

그러나 프록시 패턴은 만들기 귀찮다…

> 많은 개발자는 타깃 코드를 직접 고치고 말지 번거롭게 프록시를 만들지는 않겠다고 생각한다. 왜냐하면 프록시를 만드는 일이 상당히 번거롭게 느껴지기 때문이다.
>
> 1. 매번 새로운 클래스를 정의해야 하고,
>
> 2. 인터페이스의 구현해야 할 메소드는 많으면 모든 메소드를 일일히 구현해서 위임하는 코드를 넣어야 하기 때문이다.

### 다이나믹 프록시

그래서 우리는 직접 목 클래스를 만드는 대신 Mockito를 사용하듯, 프록시도 편리하게 사용할 수 있다.

이를 위해 리플렉션을 이용한다.

```java
package springbook.learningtest.jdk;
...

public class ReflectionTest {

	@Test
	public void invokeMethod() throws Exception {
		String name = "Spring";

		// length()
		assertThat(name.length(), is(6));
		Method lengthMethod = String.class.getMethod("length");
		assertThat((Integer)lengthMethod.invoke(name), is(6));
	}
}
```

 (리플렉션 예시. 자세한건 더 찾아보기)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c74a0b01-3522-4a2f-8fb6-6e871a7a33f7/Untitled.png)

다이나믹 프록시는 다음 방식으로 동작한다. 타깃 이후 데코레이터 패턴으로 여러 부가기능을 추가하게 된다.

### 프록시 팩토리 빈

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/40c4c48c-5cef-419a-bcc5-61f7c02899b5/Untitled.png)

> 다이내믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다.
>

> 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈(ProxyFactoryBean)을 제공한다.
>

### 자동 프록시 생성기와 포인트컷

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/009e80a7-a432-4ecc-a829-0484b63aa586/Untitled.png)

> 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 활용할 수 있다.
>

> 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
>

### AspectJ

> 포인트컷은 AspectJ 포인트컷 표현식을 사용해서 작성하면 편리하다.
>

AspectJ는 PARC에서 개발한 자바 프로그래밍 언어용 관점 지향 프로그래밍 (AOP) 확장 기능입니다.

자세한 건 더 공부…

# 참고자료

토비의 스프링 6장 AOP

[https://live-everyday.tistory.com/217](https://live-everyday.tistory.com/217)

[https://jojoldu.tistory.com/71](https://jojoldu.tistory.com/71)

[https://tecoble.techcourse.co.kr/post/2021-06-25-aop-transaction/](https://tecoble.techcourse.co.kr/post/2021-06-25-aop-transaction/)
