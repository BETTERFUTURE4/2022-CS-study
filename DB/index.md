# Index

## 인덱스란?

### 정의

Index의 사전적인 정의는 `색인` 입니다. 이를 좀 더 풀어서 얘기하면, 쉽게 찾아볼 수 있도록 일정한 순서에 따라 놓은 목록이라고 할 수 있습니다.

흔히 예시로 책의 목차를 얘기하는데, 우리가 책의 목차를 통해서 두꺼운 책의 내용을 빠르게 찾을 수 있듯이, 데이터베이스에서도 **인덱스를 통해서 빠르게 찾을 수 있다**라고 이해하면 편할 것 같습니다.


### 데이터베이스의 인덱스

아주 두꺼운 책 한 권과 데이터베이스(DBMS)를 가지고 비유를 하면 다음과 같습니다.

-   책의 맨 처음이나 끝에 존재하는 색인 = DBMS의 인덱스
-   책의 내용 = DBMS의 데이터 파일
-   책의 색인을 통해 알 수 있는 페이지 번호 = DBMS의 데이터 파일에 저장된 레코드의 주소
-   책의 색인은 사전 순으로 정렬 = DBMS의 인덱스도 일정 기준으로 정렬 가능


### 인덱스가 필요한 이유

데이터베이스에서 Java 책 정보를 찾고 싶어한다고 가정하겠습니다. 인덱스가 없다면, 처음부터 끝까지 Full Table Scan을 수행하면서 Java 책을 찾아야 하는데, 비효율적인 방법입니다.

만약 여기서 `Java`를 `Full Table Scan`으로 찾는다고 가정하면 다음과 같이 총 3개 페이지를 11번 검색하는 과정이 이루어질 것 입니다.

<img width="757" alt="Pasted image 20220827091746" src="https://user-images.githubusercontent.com/48710213/187007906-e5d80d36-9824-4848-a5b0-291b85810964.png">


하지만 여기서 Java와 관련된 컬럼과 ID를 가져와서 인덱스를 만들면, Java 책이 처음으로 등장하는 시점에서 마지막 시점까지만 탐색을 수행하면 된다.

```java
SELECT * FROM book WHERE id IN (4, 6, 8, 10, 11);
```


### 인덱스의 특징

* 인덱스는 항상 최신의 정렬상태를 유지
* 인덱스도 하나의 데이터베이스 객체
* 데이터베이스 크기의 약 10% 정도의 저장공간 필요

<br>


## 인덱스의 알고리즘

### B-Tree

B-Tree 를 설명하기 전에 이를 구성하는 핵심 요소인 `Binary Search Tree`에 대해서 한번 살펴보겠습니다. `Binary Search Tree`는 크게 다음과 같이 2가지로 구분을 할 수 있습니다.

* 군형 있는 이진탐색트리
* 균형 없는 이진탐색트리

여기서 균형 있는 이진탐색트리는 시간복잡도가 `O(log n)` 이지만 균형 없는 이진탐색트리의 경우 시간복잡도가 최악의 경우 `O(n)` 입니다. 이런 불균형한 문제를 해결하기 위해서 `B-Tree`가 나왔다고 할 수 있습니다.


`B-Tree`의 특징은 다음과 같습니다.

* 트리의 높이가 같음
* 자식 노드를 2개 이상 가질 수 있음
* 기본 데이터베이스 인덱스 구조

이런 특징들을 바탕으로 `B-Tree`를 한번 살펴보겠습니다.

`B-Tree`를 표현하면 다음과 같습니다.

<img width="1000" alt="Pasted image 20220826103124" src="https://user-images.githubusercontent.com/48710213/187007991-b6f7dd92-32b2-4625-96d5-4b3e5c2957f8.png">

**루트 페이지**와 **브랜치 페이지**에는 각 자식 페이지의 정보들을 **리프 페이지**에는 실제 데이터의 페이지가 저장되는 방식으로 `B-Tree`가 구성됩니다. 여기서 리프 페이지는 **클러스터링 인덱스**와 **논-클러스터링 인덱스**로 구분이 되는데 둘의 차이점은 **실제 데이터 페이지 정보**인지, **실제 데이터의 주소 페이지 정보**인지의 차이가 있습니다.


<br>

## 인덱스의 종류

인덱스 종류는 **클러스터링 인덱스**와 **논-클러스터링 인덱스**로 구분을 할 수 있습니다.


둘의 차이점을 간단하게 표로 정리해보면 다음과 같습니다.

| 클러스터링                       | 논-클러스터링                                  |
| -------------------------------- | ---------------------------------------------- |
| 실제 데이터와 같은 무리의 인덱스 | 실제 데이터와 다른 별도의 인덱스               |
| 실제 데이터가 정렬된 사전        | 실제 데이터 탐색을 도움을 주는 찾아보기 페이지 |



### 클러스터링 인덱스

다음과 같은 테이블이 있다고 가정하겠습니다.

``` sql
CREATE TABLE member {
    id int, 
    name varchar(255)
}

INSERT INTO member VALUES(3, '루키');
INSERT INTO member VALUES(4, '필즈');
INSERT INTO member VALUES(1, '써머');
INSERT INTO member VALUES(2, '헌치');
```

<img width="240" alt="Pasted image 20220827093455" src="https://user-images.githubusercontent.com/48710213/187008013-949f067d-c9e0-4ce5-8eee-d85f423bc25e.png">



여기에 한번 **클러스터링 인덱스**를 적용해보겠습니다.

``` sql
ALTER TABLER member
ADD CONSTRAINT pk_id PRIMARY KEY (id);

ALTER TABLE member MOFIFY COLUMN id int NOT NULL;
ALTER TABLE mebmer ADD CONSTRAINT nuq_id UNIQUE (id);
```

위의 코드 처럼 id 값에 클러스터링 인덱스를 적용한 후, 테이블을 보면 다음과 같이 정렬된 것을 확인할 수 있습니다.


<img width="242" alt="Pasted image 20220827093405" src="https://user-images.githubusercontent.com/48710213/187008035-4b038eb7-af67-4e16-a689-bd58ed48a72a.png">

또한, `B-Tree`에서 보았듯이 루트 페이지와 리프 페이지가 생기는 것도 확인할 수 있습니다.

<img width="500" alt="Pasted image 20220826111310" src="https://user-images.githubusercontent.com/48710213/187008091-93410cca-366e-49ab-b84a-d7a637100835.png">


이때까지의 내용을 바탕으로 **클러스터링 인덱스**의 특징을 정리하면 다음과 같습니다.

* 실제 데이터 자체가 정렬됨
* 테이블당 1개만 존재가 가능함 (실제 데이터가 정렬되므로)
* 리프 레이지가 곧 데이터 페이지
* primary key, unique + not null 제약 조건을 통해서 생성 가능



### 논-클러스터링 인덱스

기존과 동일하게 다음 테이블이 있다고 가정하겠습니다.

<img width="240" alt="Pasted image 20220827093455" src="https://user-images.githubusercontent.com/48710213/187008097-6864106b-85c4-4f14-8193-1d276d9a7108.png">


여기서 동일하게 논-클러스터링 인덱스를 사용해보겠습니다. 논-클러스터링 인덱스를 적용하는 방식은 Unique 제약 조건을 걸거나 Index를 직접 생성하는 것 입니다.


``` sql
ALTER TABLE member ADD CONSTRAINT unq_name UNIQUE (name);

CREATE INDEX idx_name ON member (name);
```




위의 그림을 통해서 **실제 데이터 페이지는 변하지 않고** **리프 페이지, 즉 별도의 인덱스 페이지를 생성**해서 인덱스를 수행하는 것을 확인할 수 있습니다.


이때까지의 내용을 통해서 **논-클러스터링 인덱스**의 특징에 대해서 정리해보겠습니다.

* 실제 데이터 페이지는 변경 없음
* 별도의 인덱스 페이지 생성 (리프 페이지)
* 리프 페이지에 실제 데이터 페이지 주소를 가지고 있음
* 테이블 당 여러 개 존재
* unique, 직접 index 생성으로 논-클러스터링 인덱스 생성 가능

<br>


## 인덱스 적용 기준

클러스터링, 논-클러스터링에서 보았듯이 컬럼에 제약 조건을 통해서 인덱스를 생성하는 것을 확인할 수 있었습니다. 그렇다면 이 인덱스를 설정하는 기준은 어떻게 정해야 할까요?? 바로 `카디널리티`를 통해서 결정할 수 있습니다.


카디널리티는 특정 데이터 집합의 유니크한 값의 개수를 의미합니다. 다음 예시를 통해서 카디널리티를 파악할 수 있습니다.

-   남-여 등 2가지 값만 존재하는 성별 컬럼은 **중복도가 높으며 카디널리티가 낮습니다.**
-   개인마다 고유한 값이 존재하는 주민번호 컬럼은 **중복도가 낮으며 카디널리티가 높습니다.**


즉, 카디널리티가 높은 컬럼의 경우, Index를 통해 데이터를 더 많이 필터링할 수 있기 때문에 카디널리티가 높은 컬럼에 인덱스를 설정하는 것이 좋습니다.

<br>

## 인덱스 사용 기준

-   규모가 작지 않은 테이블
-   INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
-   JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
-   데이터의 중복도가 낮은 컬럼 (카디널리티가 높은 컬럼)



<br>

> 참고 자료
* https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/
* https://rebro.kr/167
* Real MySQL 8.0 (1권)
